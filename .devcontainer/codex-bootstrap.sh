#!/usr/bin/env bash
# Configures Codex CLI for the current user.
#
# Reads non-secret settings from env vars (injected via .devcontainer/.env):
#   CC_HELPER_BASE_URL — base URL of the OpenAI-compatible server (shared with Claude Code)
#   CODEX_MODEL        — default model name
#
# Reads the API token from Docker secret (shared with Claude Code):
#   /run/secrets/cc_api_key
#
# Writes:
#   ~/.codex/config.yaml      — Codex provider + model config
#   ~/.codex/.env             — CODEX_MY_SERVER_API_KEY (read by Codex via dotenv)
#   ~/bin/codex-safe.sh       — signal-safe wrapper around `codex`
#
# Adds to ~/.bashrc (idempotent):
#   alias cc  → claude-safe.sh  (latin c + latin c)
#   alias сс  → claude-safe.sh  (cyrillic с + latin c — common typo on Russian keyboard)
#   alias cx  → codex-safe.sh   (latin c + latin x)
#   alias сч  → codex-safe.sh   (cyrillic сч — codex on Russian keyboard)
#
set -euo pipefail

CODEX_DIR="${HOME}/.codex"
mkdir -p "${CODEX_DIR}"

# ── Non-secret settings ───────────────────────────────────────────────────────
BASE_URL="${CC_HELPER_BASE_URL:-}"
MODEL="${CODEX_MODEL:-}"

if [[ -z "${BASE_URL}" ]]; then
  echo "[codex-bootstrap] CC_HELPER_BASE_URL is not set — skipping Codex config." >&2
  exit 0
fi

if [[ -z "${MODEL}" ]]; then
  echo "[codex-bootstrap] CODEX_MODEL is not set — skipping Codex config." >&2
  exit 0
fi

# ── API key from Docker secret ────────────────────────────────────────────────
SECRET_FILE="/run/secrets/cc_api_key"
API_KEY=""
if [[ -f "${SECRET_FILE}" ]]; then
  API_KEY="$(cat "${SECRET_FILE}")"
fi

if [[ -z "${API_KEY}" ]]; then
  echo "[codex-bootstrap] WARNING: /run/secrets/cc_api_key is empty — Codex will start without an API key." >&2
fi

# ── Write ~/.codex/config.yaml ────────────────────────────────────────────────
# Provider key name must be a simple identifier; we use "myserver".
# envKey refers to the env var that Codex reads for the API token.
cat > "${CODEX_DIR}/config.yaml" << YAML
# Auto-generated by .devcontainer/codex-bootstrap.sh — do not edit manually.
# Source of truth: .devcontainer/.env (CC_HELPER_BASE_URL, CODEX_MODEL)
#                  secrets/cc_api_key (API token, shared with Claude Code)

model: ${MODEL}
provider: myserver

providers:
  myserver:
    name: "MyServer"
    baseURL: "${BASE_URL}"
    envKey: CODEX_MY_SERVER_API_KEY

approvalMode: suggest
fullAutoErrorMode: ask-user
notify: false
YAML

# ── Write ~/.codex/.env — NOT used by Rust binary directly.
# The Rust binary reads env_key from the process environment, not from a file.
# We export the key via ~/.bashrc (see below) so it is set in every interactive shell.
# The file is kept as a backup reference only.
printf "CODEX_MY_SERVER_API_KEY=%s\n" "${API_KEY}" > "${CODEX_DIR}/.env"
chmod 0600 "${CODEX_DIR}/.env"

echo "[codex-bootstrap] ~/.codex/config.yaml written (provider=myserver, model=${MODEL}, baseURL=${BASE_URL})"

# ── Create ~/bin/codex-safe.sh — wrapper that injects API key into env ───────
WRAPPER_DIR="${HOME}/bin"
CODEX_WRAPPER="${WRAPPER_DIR}/codex-safe.sh"
mkdir -p "${WRAPPER_DIR}"

cat > "${CODEX_WRAPPER}" << 'WRAPPER'
#!/usr/bin/env bash
# Wrapper around `codex`.
# The Rust Codex binary reads API key from the process environment via the
# provider's env_key field. We load it from ~/.codex/.env here so it never
# appears in shell history or the global environment.
set -euo pipefail

if ! command -v codex >/dev/null 2>&1; then
  echo "codex command not found in PATH" >&2
  exit 127
fi

CODEX_ENV_FILE="${HOME}/.codex/.env"
if [ -f "${CODEX_ENV_FILE}" ]; then
  # Parse KEY=VALUE lines without sourcing (avoids shell expansion of secrets).
  while IFS='=' read -r key val; do
    case "${key}" in
      ''|\#*) continue ;;
    esac
    export "${key}=${val}"
  done < "${CODEX_ENV_FILE}"
fi

exec codex "$@"
WRAPPER

chmod +x "${CODEX_WRAPPER}"
echo "[codex-bootstrap] ${CODEX_WRAPPER} created."

# ── Add aliases to ~/.bashrc (idempotent) ─────────────────────────────────────
# cc  → claude-safe.sh  (latin cc)
# сс  → claude-safe.sh  (cyrillic с + latin c — "cc" on Russian keyboard)
# cx  → codex-safe.sh   (latin cx)
# сч  → codex-safe.sh   (cyrillic сч — "cx" on Russian keyboard)
#
# Paths with spaces in aliases break bash word splitting.
# Solution: create ~/bin/claude-safe.sh as a symlink (no spaces), point aliases there.
CLAUDE_WRAPPER_ORIG="/workspaces/work/repos/1C Framework/claude-wrapper/claude-safe.sh"
CLAUDE_WRAPPER="${WRAPPER_DIR}/claude-safe.sh"   # symlink inside ~/bin — no spaces
BASHRC="${HOME}/.bashrc"

add_alias() {
  local name="$1"
  local target="$2"
  local rc_file="$3"
  local prefix="$4"
  [ -f "${rc_file}" ] || touch "${rc_file}"
  if grep -qF "alias ${name}=" "${rc_file}" 2>/dev/null; then
    echo "[${prefix}] alias '${name}' already exists in ${rc_file} — skipping."
    return 0
  fi
  printf '\n# Added by .devcontainer/codex-bootstrap.sh\nalias %s="%s"\n' "${name}" "${target}" >> "${rc_file}"
  echo "[${prefix}] alias '${name}' added to ${rc_file}."
}

# Claude Code aliases: symlink ~/bin/claude-safe.sh -> original (avoids spaces in alias path)
if [ -f "${CLAUDE_WRAPPER_ORIG}" ]; then
  chmod +x "${CLAUDE_WRAPPER_ORIG}" 2>/dev/null || true
  ln -sfn "${CLAUDE_WRAPPER_ORIG}" "${CLAUDE_WRAPPER}"
  add_alias "cc"  "${CLAUDE_WRAPPER}" "${BASHRC}" "claude-bootstrap"
  add_alias "сс"  "${CLAUDE_WRAPPER}" "${BASHRC}" "claude-bootstrap"
else
  echo "[codex-bootstrap] claude-safe.sh not found at ${CLAUDE_WRAPPER_ORIG} — aliases 'cc'/'сс' skipped (clone the repo first)."
fi

# Codex aliases: cx (latin) and сч (cyrillic — "cx" on Russian keyboard)
add_alias "cx"  "${CODEX_WRAPPER}" "${BASHRC}" "codex-bootstrap"
add_alias "сч"  "${CODEX_WRAPPER}" "${BASHRC}" "codex-bootstrap"

echo "[bootstrap] Done. Aliases active after: source ~/.bashrc"
